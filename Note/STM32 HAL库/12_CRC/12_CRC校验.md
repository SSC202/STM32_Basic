# STM32 HAL 12_CRC校验

## 1. CRC 校验原理

**CRC(Cyclic Redundancy Check)**，即循环冗余校验，是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。CRC利用除法及余数的原理来作错误侦测。

> 在数据传输过程中，无论传输系统的设计再怎么完美，差错总会存在，这种差错可能会导致在链路上传输的一个或者多个帧被破坏(出现比特差错，0变为1，或者1变为0)，从而接受方接收到错误的数据。为尽量提高接受方收到数据的正确率，在接收方接收数据之前需要对数据进行差错检测，当且仅当检测的结果为正确时接收方才真正收下数据。
>
> 检测的方式有多种，常见的有**奇偶校验、因特网校验和循环冗余校验**等。循环冗余校验是一种用于校验通信链路上数字传输准确性的计算方法（通过某种数学运算来建立数据位和校验位的约定关系的 ）。发送方计算机使用某公式计算出被传送数据所含信息的一个值，并将此值 附在被传送数据后，接收方计算机则对同一数据进行相同的计算，应该得到相同的结果。如果这两个 CRC结果不一致，则说明发送中出现了差错，接收方计算机可要求发送方计算机重新发送该数据。

CRC 检验原理实际上就是在一个p位二进制数据序列之后附加一个r位二进制检验码(序列)，从而构成一个总长为`n＝p＋r`位的二进制序列；附加在数据序列之后的这个检验码与数据序列的内容之间存在着某种特定的关系。如果因干扰等原因使数据序列中的某一位或某些位发生错误，这种特定关系就会被破坏。

1. **帧检验序列FCS（Frame Check Sequence）**：为了进行差错检验而添加的冗余码。

2. **多项式模2运行**：实际上是按位异或(Exclusive OR)运算，即相同为0，相异为1，也就是不考虑进位、借位的二进制加减运算。

3. **生成多项式（generator polynomial）**：当进行CRC检验时，发送方与接收方需要事先约定一个除数，即生成多项式，一般记作$G(x)$。生成多项式的最高位与最低位必须是1。

> 常用的CRC码的生成多项式有：
> $$
> CRC8 = X^8 + X^5 + X^4 + X^0 \\
> CRC_{CCITT} = X^{16} + X^{12} + X^5 + X^0 \\ 
> CRC16 = X^{16} + X^{15} + X^2 + X^0 \\
> CRC12 = X^{12} + X^{11} + X^3 +X^2 + X^0 \\
> CRC32 = X^{32} + X^{26} + X^{23} +X^{22} +X^{16} +X^{12} +X^{11} +X^{10} +X^8 +X^7 +X^5 +X^4 +X^2 +X^1 + X^0 \\
> $$

每一个生成多项式都可以与一个代码相对应。如CRC8对应代码：100110001。

### 校验码的计算

设信息字段为$K$位，校验字段为$R$位，则码字长度为$N(N=K+R)$。设双方事先约定了一个$R$次多项式$g(x)$，则CRC码：
$$
V(x) = xRm(x) + r(x)
$$
$r(x)$对应的代码即为冗余码，加在原信息字段后即形成CRC码。

$r(x)$的计算方法为：在$K$位信息字段的后面添加$R$个0，再除以$g(x)$对应的代码序列，得到的余数即为$r(x)$对应的代码(应为$R－1$位；若不足，在高位补0)。

> 设需要发送的信息为M = 1010001101，产生多项式对应的代码为P = 110101，R＝5。在M后加5个0，然后对P做模2除法运算，得余数r(x)对应的代码：01110。故实际需要发送的数据是101000110101110。

### 错误检测

当接收方收到数据后，用收到的数据对P（事先约定的）进行模2除法，若余数为0，则认为数据传输无差错；若余数不为0，则认为数据传输出现了错误，由于不知道错误发生在什么地方，因而不能进行自动纠正，一般的做法是丢弃接收的数据。

> 1. CRC是一种常用的检错码，并不能用于自动纠错。
> 2. 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。
> 3. 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受（只是非常近似的认为是无差错的），并不能保证可靠传输。

### STM32 CRC